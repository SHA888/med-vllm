from typing import Any, Optional, TypeVar, Generic

T = TypeVar('T')

class tensor(Generic[T]):
    def __init__(self, data: Any, device: str = 'cuda') -> None: ...
    def to(self, device: str, **kwargs: Any) -> 'tensor[T]': ...
    def __add__(self, other: Any) -> 'tensor[T]': ...
    def __mul__(self, other: Any) -> 'tensor[T]': ...
    def __matmul__(self, other: Any) -> 'tensor[T]': ...
    def __getitem__(self, key: Any) -> 'tensor[T]': ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def shape(self) -> tuple[int, ...]: ...
    def stride(self) -> tuple[int, ...]: ...
    def numel(self) -> int: ...
    def is_contiguous(self) -> bool: ...
    def contiguous(self) -> 'tensor[T]': ...
    def view(self, *shape: int) -> 'tensor[T]': ...
    def permute(self, *dims: int) -> 'tensor[T]': ...
    def transpose(self, dim0: int, dim1: int) -> 'tensor[T]': ...
    def clone(self) -> 'tensor[T]': ...
    def copy_(self, src: 'tensor[Any]') -> None: ...
    def fill_(self, value: Any) -> None: ...
    def zero_(self) -> None: ...
    def detach(self) -> 'tensor[T]': ...
    def requires_grad_(self, requires_grad: bool = True) -> 'tensor[T]': ...
    def backward(self, gradient: Optional['tensor[Any]'] = None) -> None: ...

class language:
    @staticmethod
    def constexpr(value: Any) -> Any: ...
    
    class tensor(Generic[T]):
        def __init__(self, ptr: Any, shape: tuple[int, ...], dtype: Any) -> None: ...
        @property
        def dtype(self) -> Any: ...
        @property
        def shape(self) -> tuple[int, ...]: ...
        def __add__(self, other: Any) -> 'language.tensor[T]': ...
        def __mul__(self, other: Any) -> 'language.tensor[T]': ...
        def __matmul__(self, other: Any) -> 'language.tensor[T]': ...
        def __getitem__(self, key: Any) -> 'language.tensor[T]': ...
        def __setitem__(self, key: Any, value: Any) -> None: ...
        def to(self, dtype: Any) -> 'language.tensor[T]': ...

class cdiv:
    @staticmethod
    def __call__(x: int, y: int) -> int: ...

def next_power_of_2(x: int) -> int: ...

def static_print(*args: Any) -> None: ...

def static_assert(condition: bool, message: str = "") -> None: ...

def static_assert_shape(x: Any, *dims: int) -> None: ...

def static_range(start: int, end: int, step: int = 1) -> range: ...
